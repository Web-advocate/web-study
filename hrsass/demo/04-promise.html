<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 解决回调地狱
    // 两秒之后打印张三
    // function fn(){
    //   setTimeout(() => {
    //     console.log('张三')
    //   }, 2000);
    // }
    // fn();

    // // 三秒之后打印李四
    // function fn1(){
    //   setTimeout(() => {
    //     console.log('李四')
    //   }, 3000);
    // }
    // fn1();

    // function fn(content,time){
    //   setTimeout(() => {
    //     console.log(content);
    //   }, time);
    // }
    // fn('张三',2000)
    // fn('李四',3000)

    // 先2秒之后打印张三  接着3秒之后打印李四 
    // setTimeout(() => {
    //   console.log('张三');
    //   setTimeout(() => {
    //     console.log('李四');
    //     setTimeout(() => {
    //       console.log('王五');
    //     }, 3000);
    //   }, 3000);
    // }, 2000); 


    // 使用promise 解决回调地狱
    // promise 3中状态pending  fullfilld rejected
    // resolve改变promise的状态为成功的状态
    // rejected 改变promise的状态为失败的状态
    // function fn(time){
    //   return new Promise((resolve,reject)=>{
    //       resolve() 
    //   })
    // }
    // fn().then(res=>{
    //   setTimeout(() => {
    //     console.log('张三')
    //   }, 2000);
    //   return fn()
    // }).then(()=>{
    //   setTimeout(() => {
    //     console.log('李四')
    //   }, 3000);
    //   return fn()
    // }).then(()=>{

    // })


    // 如果像拿到promise的结果 必须把结果放到resolve中
    function fn() {
      return new Promise((resolve, reject) => {
        // new Promsie内部封装的是异步操作
        // 两秒之后编程resolve的状态
        setTimeout(() => {
          resolve({ user: '张三' })
        }, 2000);
      })
    }
    fn().then(res => {
      console.log(res)
    })
  </script>
</body>

</html>